/* M13
   ===
   
   Sebastian Egner (egner@informatik.uni-karlsruhe.de)
   6. August 1997
   in Java v1.0, API v1.0.2

   The applet M13 provides an interactive puzzle for one person
   which is based on the structure M_13 described by John H. Conway
   in reference [1]. The groupoid M_13 is based on the projective
   geometry PG(2,3). It is a set of permutations which contains the
   famous sporadic simple group M_12 as its "hole stabilizer". The
   M_12 is generated by all triangle moves A B A which return the
   hole where it has been before.

   The aim of the game is to sort the counters into a fixed order
   by a sequence of moves. A move is initiated by clicking onto a
   counter hence moving it into the hole.

   reference
     [1] J. H. Conway: M_13.
         in R. A. Bailey (ed.): Surveys in Combinatorics, 1997
         London Math. Soc. Lect. Notes Series 241 (1997).

   history of the project
     6.8.97 first version in Java, following my GAP-implementation
     7.8.97 the solver, produced with AbstractStabChain by 
            Sebastian Egner and Markus P"uschel
     8.8.97 debugged; solver improved to yield shorter words;
            "the look"
  
   compile this file with
     javac -g M13.java
*/

import java.util.*;
import java.awt.*;
import java.applet.*;

/* M13
     an applet which provides the entire game.
*/

public class M13 extends Applet implements Runnable {

// The widgets

  M13Canvas canvas;         // where everything happens
  Button    scrambleButton; // to scramble the puzzle 
  Button    solveButton;    // to solve it
  Button    stopButton;     // to stop solving
  Button    resetButton;    // to reset it  
  Scrollbar speedSlider;    // to control the velocity
  
// Derived layout constants from canvas

  int counterHalfSizeSquared; 
    // squared radius of a counter in pixels^2

// Simulation parameters

  long   frameDelay     = 40;  // ms  
  double velocity       = 1.1; // canvas.totalSize/s
  double minVelocity    = 0.2; 
  double maxVelocity    = 2.0;

// State of the simulation

  boolean initialized = false;
    // Is the applet initialized?

  boolean running = false; 
    // Is the simulation running now?

  int counterAt[] = new int[26]; 
    // Which counter (0..12, 12 = hole) is at tick position k?

  int trajectory[][] = new int[3][4];
    // How to move the counters: 
    //   trajectory[i][0] is the nr. of a counter,
    //   trajectory[i][1] is its current tick position
    //   trajectory[i][2] is its intermediate tick position
    //   trajectory[i][3] is its final tick position

  int counters[][] = new int[21][2];
    // variable used to set counter position

  boolean showMoves = true;        // show the moves or just update position?
  int     nrMoves   = 0,           // nr. of remaining moves to do
          moves[]   = new int[10]; // the moves 

  Random random; // a pseudo-random sequence

// The solution algoithm

  M13Solver solver = new M13Solver();

// Initializing and running the applet

  public void init() {
  
    // define the layout of the applet
    setLayout(new BorderLayout());
      canvas = new M13Canvas();
    add("Center", canvas);
      Panel controls = new Panel();
      controls.setLayout(new BorderLayout());
        speedSlider = 
          new Scrollbar(
            Scrollbar.HORIZONTAL,
            50,
            1,
            0,
            100
          );
      controls.add("North", speedSlider);
        Panel buttons = new Panel();
        buttons.setLayout(new GridLayout(1,4));
          scrambleButton = new Button("scramble");
        buttons.add(scrambleButton);
          solveButton = new Button("solve");
        buttons.add(solveButton);
          stopButton = new Button("stop");
        buttons.add(stopButton);
          resetButton = new Button("reset");
        buttons.add(resetButton);
      controls.add("South", buttons);
    add("South", controls);

    // initialize canvas
    canvas.init();
    
    // modify the layout of this
    scrambleButton.setFont(canvas.buttonFont);
    solveButton.setFont(canvas.buttonFont);
    stopButton.setFont(canvas.buttonFont);
    resetButton.setFont(canvas.buttonFont);
    
    // precompute derived layout constants
    counterHalfSizeSquared = 
      (int)Math.round(
        (canvas.counterSize/2.0 * canvas.totalSize) *
        (canvas.counterSize/2.0 * canvas.totalSize)
      );
      
    // initialize state of the simulation
    running = false;
    for (int k = 0; k < 26; ++k)
      counterAt[k] = 12;
    for (int c = 0; c < 12; ++c)
      counterAt[2*(c+1)] = c;

    // initialize the pseudo-random sequence
    random = new Random(1);
    for (int i = 0; i < 100; ++i)
      int dummy = random.nextInt();
  }
  
  // startMove(c) initiates the move which transfers counter c
  //              into the hole. This is done by filling trajectory[].
  // finishMove() finishes the current move by using trajectory[]
  //              to update counterAt

  public void startMove(int c) {

    // compute the positions k(c) and k(hole)    
    int kc = 0;
    while ((kc < 26) && (counterAt[kc] != c))
      kc += 2;

    int kHole = 0;
    while ((kHole < 26) && (counterAt[kHole] != 12))
      kHole += 2;

    // compute the position k(L) of the line L joining c and hole
    int kL = 1;
    while (
      (kL < 26) &&
      (!(
        ( ((kL +  1)%26 == kc) ||
          ((kL +  9)%26 == kc) ||
          ((kL + 21)%26 == kc) ||
          ((kL + 25)%26 == kc)
        ) &&
        ( ((kL +  1)%26 == kHole) ||
          ((kL +  9)%26 == kHole) ||
          ((kL + 21)%26 == kHole) ||
          ((kL + 25)%26 == kHole)
        )
      ))
    )
      kL += 2;

    // find the other two points of L, a and b
    int ka  = -1;
    int kb  = -1;
    int d[] = {1, 9, 21, 25};
    for (int i = 0; i < 4; ++i) {
      int k = (kL + d[i])%26;
      if ((k != kc) && (k != kHole)) {
        if (ka == -1)
          ka = k;
        else
          kb = k;
      }
    }
    
    // prepare the trajectories of a, b, c
    trajectory[0][0] = counterAt[ka];
    trajectory[0][1] = ka;
    trajectory[0][2] = kL;
    trajectory[0][3] = kb;

    trajectory[1][0] = counterAt[kb];
    trajectory[1][1] = kb;
    trajectory[1][2] = kL;
    trajectory[1][3] = ka;

    trajectory[2][0] = counterAt[kc];
    trajectory[2][1] = kc;
    trajectory[2][2] = kL;
    trajectory[2][3] = kHole;
  }

  public void finishMove() {
    counterAt[trajectory[2][1]] = 12;
    for (int i = 0; i < 3; ++i)
      counterAt[trajectory[i][3]] = trajectory[i][0];
  }

  // start() creates the actual thread to perform the moves
  //         the information is taken from nrMoves, moves[]
  //         and showMoves.
  // run()   periodically updates the canvas to show the
  //         intermediate positions of the counters; the
  //         information where to draw the counters comes
  //         from trajectory[] and from the frame counter
  // stop()  aborts a move jumping to the final positions

  public void start() {
    if (!initialized) {
      return; // avoids starting the thread right after init()
    }
    running = true;
    (new Thread(this)).start();
  }

  public void run() { 
    while ((nrMoves > 0) && running) {
    
      // get the next move and set trajectory[]
      if (showMoves)
        showStatus(
          "moving " + String.valueOf(moves[0]+1)
        );
      startMove(moves[0]);
      for (int i = 0; i < nrMoves-1; ++i)
        moves[i] = moves[i+1];
      nrMoves = nrMoves - 1;

    
      // show the move
      if (showMoves) {
        double  moveVelocity = velocity;
        int     frame        = -1;
        boolean finished     = false;
        while ((!finished) && running) {
          ++frame;

          // update canvas
          finished = setCounters(moveVelocity, frame);
          canvas.repaint();

          // sleep for frameDelay
          try {
            Thread.sleep(frameDelay);
          } catch (InterruptedException e) {
            stop();
            return;
          }
        }
      }
      
      // update the counters to the new position
      finishMove();
    }
    
    // set the counters to the final position; repaint
    for (int k = 0; k < 26; k += 2) {
      if (counterAt[k] != 12) {
        counters[counterAt[k]][0] = canvas.ticks[k][0];
        counters[counterAt[k]][1] = canvas.ticks[k][1];
      }
    }
    canvas.setCounters(counters);
    canvas.repaint();    
    showStatus("ready");
    stop();
  }

  public void stop() {
    
    // clear the moves
    nrMoves = 0;

    // advance to final position of current move
    counterAt[trajectory[2][1]] = 12;
    for (int i = 0; i < 3; ++i)
      counterAt[trajectory[i][3]] = trajectory[i][0];
  
    // set the counters to the final position; repaint
    for (int k = 0; k < 26; k += 2) {
      if (counterAt[k] != 12) {
        counters[counterAt[k]][0] = canvas.ticks[k][0];
        counters[counterAt[k]][1] = canvas.ticks[k][1];
      }
    }
    canvas.setCounters(counters);
    canvas.repaint();

    // unlock the simulation
    running = false;
  }
  
  // setCounters(velocity, frame) 
  //   computes the current pixel positions of all counters,
  //   calles canvas.setCounter() with these positions and
  //   returns whether the animation has finished.
  //   The motion has constant velocity.
  
  boolean setCounters(double velocity, int frame) {
          
    // initialize counters
    for (int k = 0; k < 26; k += 2) {
      if (counterAt[k] != 12) {
        counters[counterAt[k]][0] = canvas.ticks[k][0];
        counters[counterAt[k]][1] = canvas.ticks[k][1];
      }
    }

    // interpolate the moving counters
    double 
      T  = frame * (double)frameDelay * 1.0e-3, // absolute time in s
      dT = T * velocity * canvas.totalSize; // absolute distance/pixels

    int finished = 0;    
    for (int i = 0; i < 3; ++i) {
      int 
        c  = trajectory[i][0],    // a counter

        k0 = trajectory[i][1],    // initial tick position
        x0 = canvas.ticks[k0][0], // initial position, x
        y0 = canvas.ticks[k0][1], // initial position, y

        k1 = trajectory[i][2],    // intermediate tick position
        x1 = canvas.ticks[k1][0], // intermediate position, x
        y1 = canvas.ticks[k1][1], // intermediate position, y

        k2 = trajectory[i][3],    // final tick position
        x2 = canvas.ticks[k2][0], // final position, x
        y2 = canvas.ticks[k2][1]; // final position, y

      double
        d01 = Math.sqrt((double)((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0))),
        d12 = Math.sqrt((double)((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)));

      // use Kochanek-Bartels spline to give more drive
      double d = dT/(d01 + d12);
      if ((0.0 <= d) && (d <= 1.0)) {
        d = d*d*(3.0 - 2.0*d);
      }
      d = d * (d01 + d12);
     
      // interpolate the position using d
      int x, y;        
      if (d <= d01) {

        // somewhere between (x0, y0) and (x1, y1)
        double 
          u  = d/d01,
          v  = 1.0 - u;

        x = (int)Math.round(u * (double)x1 + v * (double)x0);
        y = (int)Math.round(u * (double)y1 + v * (double)y0);
          
      } else
      if (d <= d01 + d12) {

        // somewhere between (x1, y1) and (x2, y2)
        double 
          u  = (d - d01)/d12,
          v  = 1.0 - u;

        x = (int)Math.round(u * (double)x2 + v * (double)x1);
        y = (int)Math.round(u * (double)y2 + v * (double)y1);

      } else {

        // at (x2, y2)
        x = x2;
        y = y2;
        ++finished;
      }
      
      // set the position of c to (x, y)
      counters[c][0] = x;
      counters[c][1] = y;
    }
    canvas.setCounters(counters);
    return (finished == 3);
  }
  
  // handleEvent() 
  //   initiates a move via startMove()

  public boolean handleEvent(Event e) {
    if ((e.target == canvas) && (e.id == Event.MOUSE_DOWN)) {
      if (!running) {

        // check if mouse down initiates a move
        for (int k = 0; k < 26; k += 2) {
          int 
            dx = e.x-canvas.location().x - canvas.ticks[k][0],
            dy = e.y-canvas.location().y - canvas.ticks[k][1];

          if (dx*dx + dy*dy <= counterHalfSizeSquared) {
          
            // mouse hit near tick nr. k
            if (counterAt[k] != 12) {
            
              // try to start moving the counter at k into the hole
              moves       = new int[1];
              moves[0]    = counterAt[k];
              nrMoves     = 1;
              showMoves   = true;
              initialized = true;
              start();
              return super.handleEvent(e);
            }
          }
        }
      }
      return true;
    } 
    if ((e.target == scrambleButton) && (e.id == Event.ACTION_EVENT)) {
      requestFocus();
      if (!running) {

        // make a number of random moves (1024..2047)
        int n = 1024 + (random.nextInt() & 1023);
        for (int i = 0; i < n; ++i) {
          int c = random.nextInt() & 15;
          if ((0 <= c) && (c <= 11)) {
            startMove(c);
            finishMove();
          }
        }
        
        // set the new positions and repaint
        for (int k = 0; k < 26; k += 2) {
          if (counterAt[k] != 12) {
            counters[counterAt[k]][0] = canvas.ticks[k][0];
            counters[counterAt[k]][1] = canvas.ticks[k][1];
          }
        }
        canvas.setCounters(counters);
        canvas.repaint();
      }
      return true;
    }
    if ((e.target == solveButton) && (e.id == Event.ACTION_EVENT)) {
      requestFocus();
      if (!running) {
      
        // compute a solution
        moves   = solver.solve(counterAt);
        nrMoves = moves.length;

        // run the show
        showMoves   = true;
        initialized = true;
        if (nrMoves > 0)
          start();
      }
      return true;
    }
    if ((e.target == stopButton) && (e.id == Event.ACTION_EVENT)) {
      requestFocus();
      if (running)
        running = false;
      return true;
    }
    if ((e.target == resetButton) && (e.id == Event.ACTION_EVENT)) {
      requestFocus();
      if (!running) {

        // reset the counters
        for (int k = 0; k < 26; ++k)
          counterAt[k] = 12;
        for (int c = 0; c < 12; ++c)
          counterAt[2*(c+1)] = c;
          
        // set the new positions and repaint
        for (int k = 0; k < 26; k += 2) {
          if (counterAt[k] != 12) {
            counters[counterAt[k]][0] = canvas.ticks[k][0];
            counters[counterAt[k]][1] = canvas.ticks[k][1];
          }
        }
        canvas.setCounters(counters);
        canvas.repaint();
      }
      return true;
    }
    if (e.target == speedSlider) {
      requestFocus();
      double v = (double)( speedSlider.getValue() ); // 0..100
      velocity = minVelocity + v/100.0 * (maxVelocity - minVelocity);
      return true;
    }
    return super.handleEvent(e);
  }
}

/* M13Canvas
     a canvas which supplies the graphics operations needed
     to move the counters around. The primary interface are
     the methods setCounters() and paint() which set the
     position of the counters and show the new situation.
*/

class M13Canvas extends Canvas {
  
// Layout parameters
  
  public int    totalSize   = 500;  // total width = total height in pixels
  public double tickSize    = 0.02; // diameter rel. to totalSize  
  public double counterSize = 0.08; // diameter rel. to totalSize
 
  Color backgroundColor   = Color.lightGray;
  Color lineColor         = Color.black;
  Color tickColor         = Color.black;
  Color counterLabelColor = Color.black;
  Color counterColor[]    = {
    new Color(255,  64,  64),
    new Color(238, 128,  17),
    new Color(191, 191,   0),
    new Color(127, 238,  17),
    new Color( 64, 255,  64),
    new Color( 17, 238, 128),
    new Color(  0, 191, 191),
    new Color( 17, 127, 238),
    new Color( 64,  64, 255),
    new Color(127,  17, 238),
    new Color(191,   0, 191),
    new Color(238,  17, 127)
  };
  
  Font labelFont    = new Font("Helvetica", Font.PLAIN, 18);
  Font buttonFont   = new Font("Helvetica", Font.PLAIN, 12);
  Font titleFonts[] = 
    { new Font("TimesRoman", Font.ITALIC, 50),
      new Font("TimesRoman", Font.PLAIN,  38),
      new Font("Helvetica",  Font.PLAIN,  12)
    };

// Derived layout constants

  public int ticks[][] = new int[26][2]; 
    // coordinates of the PG(2,3)-points/lines
    // (point/line alternating, point 0 top, clockwise)

  double ticksDir[][] = new double[26][2];
    // normalized direction from center to ticks[k]

  int tickPointRadius,   // radius of a "point"-tick in pixels
      tickPointDiameter, // diameter of a "point"-tick in pixels
      tickLineLength;    // length of half a "line"-tick in pixels

  int counterRadius,   // radius of counter in pixels
      counterDiameter; // diameter of counter in pixels

  int labelDisplacement[][] = new int[3][2]; 
    // displacement to center labels

  int titlePositions[][] = new int[3][2];
    // positions of the title strings
 
// Double buffering facilities
 
  Image    bufferImage = null; // off-screen buffer
  Graphics bufferGraphics;     // bufferImage.getGraphics()

// State variables

  int counters[][] = new int[12][2];

// Instantiation and initialization methods

  public M13Canvas() {
  }

  public void init() {
  
    // allocate double buffer
    bufferImage    = createImage(totalSize, totalSize);
    bufferGraphics = bufferImage.getGraphics();
    
    // precompute derived layout constants
    ticks    = new int[26][2];
    ticksDir = new double[26][2];
    for (int k = 0; k < 26; ++k) {
      double 
        c0 = 0.5 * (double) totalSize,
        c1 = 0.5 * (double) totalSize * 0.89,
        a0 = 2.0*Math.PI/26.0;

      ticksDir[k][0] =  Math.sin(a0 * (double)k);
      ticksDir[k][1] = -Math.cos(a0 * (double)k);

      ticks[k][0] = (int)Math.round(c0 + c1*ticksDir[k][0]);
      ticks[k][1] = (int)Math.round(c0 + c1*ticksDir[k][1]);
    }    
    
    tickPointRadius   = (int)Math.round(tickSize * totalSize / 2.0);
    tickPointDiameter = (int)Math.round(tickSize * totalSize);
    tickLineLength    = (int)Math.round(tickSize * totalSize);
    
    counterRadius   = (int)Math.round(counterSize * totalSize / 2.0);
    counterDiameter = (int)Math.round(counterSize * totalSize);

    // displacements for the labels   
    { 
      bufferGraphics.setFont(labelFont);
      FontMetrics fm = bufferGraphics.getFontMetrics();
      int         w  = fm.charWidth('0'),
                  h  = (fm.getAscent()*80)/100;

      /* label of length 0 */
      labelDisplacement[0][0] = 0;
      labelDisplacement[0][1] = 0;

      /* label of length 1 */
      labelDisplacement[1][0] = -w/2;
      labelDisplacement[1][1] = +h/2;

      /* label of length 2 */
      labelDisplacement[2][0] = -w;
      labelDisplacement[2][1] = +h/2;      
    }

    // displacements for the title
    {
      bufferGraphics.setFont(titleFonts[0]);
      FontMetrics fm1 = bufferGraphics.getFontMetrics();
      int 
        w1 = fm1.stringWidth("M"),
        h1 = fm1.getAscent();
      bufferGraphics.setFont(titleFonts[1]);
      FontMetrics fm2 = bufferGraphics.getFontMetrics();
      int
        w2 = fm2.stringWidth("13"),
        h2 = fm2.getAscent();
      int 
        w = w1 + w2,
        h = h1 + (h1*25)/100;

      titlePositions[0][0] = totalSize/2                - (w*45)/100;
      titlePositions[0][1] = totalSize/2 - (h1*25)/100  + (h*45)/100;
      titlePositions[1][0] = titlePositions[0][0] + w1;
      titlePositions[1][1] = titlePositions[0][1] + (h1*25)/100;

      bufferGraphics.setFont(titleFonts[2]);
      FontMetrics fm3 = bufferGraphics.getFontMetrics();
      int
        w3 = fm3.stringWidth("by Sebastian Egner, 1997"),
        h3 = fm3.getAscent();

      titlePositions[2][0] = totalSize - (w3*105)/100;
      titlePositions[2][1] = totalSize - (h3*105)/100;
    }
    
    // initialize state variables
    for (int c = 0; c < 12; ++c) {
      counters[c][0] = ticks[2*(c+1)][0];
      counters[c][1] = ticks[2*(c+1)][1];
    }
  }

// (Re)drawing the canvas
 
  public void update(Graphics screen) {

    // do *not* clear the screen and paint from scratch
    paint(screen);
  }
 
  public void paint(Graphics screen) {
    Graphics g = bufferGraphics; // abbreviation
  
    // clear buffer
    g.setColor(backgroundColor);
    g.fillRect(0, 0, totalSize, totalSize);

    // draw title
    g.setColor(lineColor);
    g.setFont(titleFonts[0]);
    g.drawString("M", titlePositions[0][0], titlePositions[0][1]);
    g.setFont(titleFonts[1]);
    g.drawString("13", titlePositions[1][0], titlePositions[1][1]);
    g.setFont(titleFonts[2]);
    g.drawString(
      "by Sebastian Egner, 1997", 
      titlePositions[2][0], 
      titlePositions[2][1]
    );

    // draw incidence edges of PG(2,3)
    g.setColor(lineColor);
    for (int k = 0; k < 26; k += 2) {

      // join k to k+1, +5, +17, +25
      g.drawLine(
        ticks[k][0], 
        ticks[k][1],
        ticks[(k + 1)%26][0], 
        ticks[(k + 1)%26][1]
      );
      g.drawLine(
        ticks[k][0], 
        ticks[k][1],
        ticks[(k + 5)%26][0], 
        ticks[(k + 5)%26][1]
      );
      g.drawLine(
        ticks[k][0], 
        ticks[k][1],
        ticks[(k + 17)%26][0], 
        ticks[(k + 17)%26][1]
      );
      g.drawLine(
        ticks[k][0], 
        ticks[k][1],
        ticks[(k + 25)%26][0], 
        ticks[(k + 25)%26][1]
      );
    }

    // draw "point"- and "line"-ticks of PG(2,3)
    g.setColor(tickColor);
    for (int k = 0; k < 26; ++k) {
      if (k % 2 == 0) {

        // draw tick as point
        g.fillOval(
          ticks[k][0] - tickPointRadius,
          ticks[k][1] - tickPointRadius,
          tickPointDiameter,
          tickPointDiameter
        );
        
      } else {

        // draw tick as line
        int 
          dx = (int)Math.round(tickLineLength * ticksDir[k][0]),
          dy = (int)Math.round(tickLineLength * ticksDir[k][1]);
          
        g.drawLine(
          ticks[k][0] - dx,
          ticks[k][1] - dy,
          ticks[k][0] + dx,
          ticks[k][1] + dy
        );
        
      }
    }

    // draw counters
    char label[] = new char[2];
    for (int c = 0; c < 12; ++c) {
      
      // the counter disk
      g.setColor(counterColor[c]);      
      g.fillOval(
        counters[c][0] - counterRadius,
        counters[c][1] - counterRadius,
        counterDiameter,
        counterDiameter
      );
      g.setColor(lineColor);
      g.drawOval(
        counters[c][0] - counterRadius,
        counters[c][1] - counterRadius,
        counterDiameter,
        counterDiameter
      );
      
      // the label
      g.setColor(counterLabelColor);
      g.setFont(labelFont); // ...
      if (c+1 < 10) {
      
        // one-digit label
        label[0] = Character.forDigit(c+1, 10);
        g.drawChars(
          label,
          0, 
          1,
          counters[c][0] + labelDisplacement[1][0],
          counters[c][1] + labelDisplacement[1][1]
        );
      } else {

        // two-digit label
        label[0] = Character.forDigit(1, 10);
        label[1] = Character.forDigit(c+1-10, 10);
        g.drawChars(
          label,
          0, 
          2,
          counters[c][0] + labelDisplacement[2][0],
          counters[c][1] + labelDisplacement[2][1]
        );
      }
    }

    // map buffer to screen
    screen.drawImage(bufferImage, 0, 0, this);
  }
  
// Setting the positions of the counters

  public void setCounters(int counters[][]) {
    for (int c = 0; c < 12; ++c) {
      this.counters[c][0] = counters[c][0];
      this.counters[c][1] = counters[c][1];
    }
  }
}

/* M13Solver
     a class which provides the solution algorithm for the 
     monoid M_13 in terms of moving the counters. Encodings:
     
     counter:  {0..11} are the counters labeled (1)..(12).
               In addition, the counter 12 is the hole.
     tick:     {0..25} are the tick positions such that
               0 is the "point"-tick on top and counting 
               is clockwise; "point"-ticks and "line"-ticks 
               alternate
     state:    an array int state[26] which maps positions
               into counters (incl. hole), {0..12}.
     move:     the number of a proper counter {0..11} which
               is to be moved into the hole
     perm:     a permutation which takes state into state*perm.
               The perm is an array int array[13] which maps
               the counter (incl. hole) at tick position 2*k
               into the tick position 2*perm[k].
*/

class M13Solver extends Object {

// The stabilizer chain of M12
// ===========================
//
//   Computed with the GAP v3.4 program "abstabch.g" written
//   jointly by Sebastian Egner and Markus P"uschel.
//
//   Summary of the abstract stabchain (points in GAP-convention)
//
// ASC(
// # level basepoint cosets  (orbit size) (max. length) (avg. length)
// #     1        12     12           12+             1           0.9
// #     2         2     11           11+             2           1.0
// #     3         9     10           10+             2           1.3
// #     4         7      9            9+             3           1.8
// #     5        13      8            8+             4           2.8
// #
// # total:              50           50*            12           7.9
// #    (orbits: + = complete, * = generating set known)
// )
//
//   Description of the data structures
//
// int nrPoints;
//   /* The degree of the permutation group. The points
//      are numbered [0..nrPoints-1].
//   */
//
// int nrBasepoints;
// int basepoints[];
//   /* The base points. */
//
// int nrGenerators;
// int generators[][];
//   /* The permutations which are the generators. The
//      generators g are numbered [1..nrGenerators].
//      (To allow inverse powers in the words!) 
//      Generator g maps the point p to the point
//        generators[g-1][p].
//   */
//
// int transversals[][][];
// int words[][][];
//   /* The transversals and their corresponding words
//      in the generators. transversals[level][im] is a
//      permutation, that is maps point p into
//        transversals[level][im][p].
//      In particular, transversals[level][im] stabilizes
//      all points basepoints[0], .., basepoints[level-1]
//      and maps basepoints[level] into the image point im.
//      The permutation transversals[level][im] has been
//      factored into the word 
//        words[level][im].
//      The word is a 0-terminated list of the generators g
//      or the inverse generators -g which form the word
//      in the abstract generators. An entry which is not
//      in the orbit of basepoints[level] is written as
//        transversals[level][im] = { -1, .., -1 };
//        words[level][im] = { 0 };
//    */

int nrPoints = 13;

int nrBasepoints = 5;
int basepoints[] = {11, 1, 8, 6, 12};

int nrGenerators   = 54;
int generators[][] =
  { {0, 2, 1, 7, 4, 11, 12, 3, 8, 9, 10, 5, 6},
    {0, 3, 7, 1, 8, 11, 6, 2, 4, 9, 10, 5, 12},
    {0, 4, 2, 8, 1, 11, 6, 7, 3, 9, 12, 5, 10},
    {0, 6, 12, 3, 4, 11, 1, 7, 9, 8, 10, 5, 2},
    {0, 7, 3, 2, 4, 11, 6, 1, 8, 10, 9, 5, 12},
    {0, 8, 2, 4, 3, 11, 9, 7, 1, 6, 10, 5, 12},
    {0, 9, 2, 3, 4, 11, 8, 10, 6, 1, 7, 5, 12},
    {0, 10, 2, 3, 12, 11, 6, 9, 8, 7, 1, 5, 4},
    {0, 12, 6, 3, 10, 11, 2, 7, 8, 9, 4, 5, 1},
    {0, 1, 4, 7, 2, 9, 6, 3, 8, 5, 12, 11, 10},
    {0, 11, 5, 7, 9, 2, 6, 3, 8, 4, 10, 1, 12},
    {0, 12, 6, 7, 4, 5, 2, 3, 9, 8, 10, 11, 1},
    {0, 1, 8, 7, 4, 5, 9, 3, 2, 6, 11, 10, 12},
    {0, 1, 9, 7, 5, 4, 8, 3, 6, 2, 10, 11, 12},
    {0, 1, 10, 7, 12, 5, 6, 3, 11, 9, 2, 8, 4},
    {0, 5, 11, 7, 4, 1, 6, 3, 10, 9, 8, 2, 12},
    {0, 6, 12, 7, 10, 5, 1, 3, 8, 9, 4, 11, 2},
    {0, 8, 7, 4, 3, 5, 6, 2, 1, 9, 12, 11, 10},
    {0, 11, 7, 5, 4, 3, 10, 2, 8, 9, 6, 1, 12},
    {0, 1, 7, 6, 4, 10, 3, 2, 9, 8, 5, 11, 12},
    {0, 4, 7, 8, 1, 5, 9, 2, 3, 6, 10, 11, 12},
    {0, 1, 7, 9, 4, 5, 8, 2, 6, 3, 10, 12, 11},
    {0, 1, 7, 10, 12, 6, 5, 2, 8, 9, 3, 11, 4},
    {0, 5, 7, 11, 4, 1, 6, 2, 8, 12, 10, 3, 9},
    {0, 1, 7, 12, 10, 5, 6, 2, 8, 11, 4, 9, 3},
    {0, 11, 9, 3, 5, 4, 6, 7, 8, 2, 12, 1, 10},
    {0, 1, 2, 3, 6, 5, 4, 11, 9, 8, 12, 7, 10},
    {0, 1, 3, 2, 7, 5, 11, 4, 8, 9, 12, 6, 10},
    {0, 3, 2, 1, 8, 5, 9, 7, 4, 6, 12, 11, 10},
    {0, 1, 5, 3, 9, 2, 8, 7, 6, 4, 12, 11, 10},
    {0, 5, 2, 3, 11, 1, 7, 6, 8, 9, 12, 4, 10},
    {0, 11, 2, 10, 4, 6, 5, 7, 9, 8, 3, 1, 12},
    {0, 11, 3, 2, 4, 7, 6, 5, 12, 9, 10, 1, 8},
    {0, 11, 2, 3, 4, 8, 9, 12, 5, 6, 10, 1, 7},
    {0, 11, 4, 3, 2, 9, 8, 7, 6, 5, 10, 1, 12},
    {0, 11, 2, 6, 12, 10, 3, 7, 8, 9, 5, 1, 4},
    {0, 11, 2, 3, 10, 12, 6, 8, 7, 9, 4, 1, 5},
    {0, 1, 3, 2, 11, 5, 7, 6, 9, 8, 10, 4, 12},
    {0, 1, 2, 5, 12, 3, 10, 7, 9, 8, 6, 11, 4},
    {0, 5, 2, 3, 7, 1, 11, 4, 9, 8, 10, 6, 12},
    {0, 2, 1, 3, 10, 5, 12, 7, 9, 8, 4, 11, 6},
    {0, 1, 3, 2, 4, 12, 9, 8, 7, 6, 10, 11, 5},
    {0, 10, 3, 2, 4, 5, 8, 9, 6, 7, 1, 11, 12},
    {0, 9, 3, 2, 12, 5, 6, 10, 8, 1, 7, 11, 4},
    {0, 5, 3, 2, 6, 1, 4, 11, 8, 9, 10, 7, 12},
    {0, 1, 3, 2, 10, 8, 6, 12, 5, 9, 4, 11, 7},
    {0, 1, 11, 3, 12, 5, 9, 7, 10, 6, 8, 2, 4},
    {0, 5, 10, 3, 4, 1, 9, 7, 11, 6, 2, 8, 12},
    {0, 1, 2, 3, 10, 7, 9, 5, 12, 6, 4, 11, 8},
    {0, 7, 2, 3, 12, 5, 8, 1, 6, 10, 9, 11, 4},
    {0, 5, 2, 12, 4, 1, 8, 7, 6, 11, 10, 9, 3},
    {0, 1, 2, 11, 10, 5, 8, 7, 6, 12, 4, 3, 9},
    {0, 5, 8, 3, 12, 1, 6, 7, 2, 9, 11, 10, 4},
    {0, 5, 2, 9, 10, 1, 6, 7, 8, 3, 4, 12, 11}
  };

int transversals[][][] =
  { { {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
      {0, 11, 5, 7, 9, 2, 6, 3, 8, 4, 10, 1, 12},
      {0, 5, 11, 7, 4, 1, 6, 3, 10, 9, 8, 2, 12},
      {0, 5, 7, 11, 4, 1, 6, 2, 8, 12, 10, 3, 9},
      {0, 5, 2, 3, 11, 1, 7, 6, 8, 9, 12, 4, 10},
      {0, 2, 1, 7, 4, 11, 12, 3, 8, 9, 10, 5, 6},
      {0, 1, 3, 2, 7, 5, 11, 4, 8, 9, 12, 6, 10},
      {0, 1, 2, 3, 6, 5, 4, 11, 9, 8, 12, 7, 10},
      {0, 1, 10, 7, 12, 5, 6, 3, 11, 9, 2, 8, 4},
      {0, 1, 7, 12, 10, 5, 6, 2, 8, 11, 4, 9, 3},
      {0, 1, 8, 7, 4, 5, 9, 3, 2, 6, 11, 10, 12},
      {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12},
      {0, 1, 7, 9, 4, 5, 8, 2, 6, 3, 10, 12, 11}
    },
    { {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
      {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12},
      {0, 2, 1, 3, 10, 5, 12, 7, 9, 8, 4, 11, 6},
      {0, 3, 2, 1, 8, 5, 9, 7, 4, 6, 12, 11, 10},
      {0, 4, 7, 8, 1, 5, 9, 2, 3, 6, 10, 11, 12},
      {0, 5, 7, 4, 10, 9, 6, 12, 8, 1, 3, 11, 2},
      {0, 6, 12, 7, 10, 5, 1, 3, 8, 9, 4, 11, 2},
      {0, 7, 2, 3, 12, 5, 8, 1, 6, 10, 9, 11, 4},
      {0, 8, 7, 4, 3, 5, 6, 2, 1, 9, 12, 11, 10},
      {0, 9, 3, 2, 12, 5, 6, 10, 8, 1, 7, 11, 4},
      {0, 10, 3, 2, 4, 5, 8, 9, 6, 7, 1, 11, 12},
      {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
      {0, 12, 6, 7, 4, 5, 2, 3, 9, 8, 10, 11, 1}
    },
    { {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
      {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
      {0, 1, 3, 8, 5, 10, 7, 9, 2, 6, 4, 11, 12},
      {0, 1, 8, 2, 10, 4, 9, 6, 3, 7, 5, 11, 12},
      {0, 1, 7, 8, 9, 12, 3, 5, 4, 6, 2, 11, 10},
      {0, 1, 3, 2, 10, 8, 6, 12, 5, 9, 4, 11, 7},
      {0, 1, 9, 7, 5, 4, 8, 3, 6, 2, 10, 11, 12},
      {0, 1, 3, 2, 4, 12, 9, 8, 7, 6, 10, 11, 5},
      {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12},
      {0, 1, 7, 6, 4, 10, 3, 2, 9, 8, 5, 11, 12},
      {0, 1, 4, 7, 12, 3, 5, 9, 10, 6, 2, 11, 8},
      {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
      {0, 1, 2, 3, 10, 7, 9, 5, 12, 6, 4, 11, 8}
    },
    { {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
      {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
      {0, 1, 6, 5, 4, 3, 2, 10, 8, 12, 7, 11, 9},
      {0, 1, 10, 7, 9, 2, 3, 6, 8, 12, 5, 11, 4},
      {0, 1, 6, 9, 2, 7, 4, 12, 8, 10, 3, 11, 5},
      {0, 1, 7, 10, 12, 6, 5, 2, 8, 9, 3, 11, 4},
      {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12},
      {0, 1, 5, 6, 12, 10, 7, 3, 8, 4, 2, 11, 9},
      {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
      {0, 1, 3, 12, 10, 6, 9, 4, 8, 5, 7, 11, 2},
      {0, 1, 3, 2, 9, 7, 10, 5, 8, 4, 6, 11, 12},
      {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
      {0, 1, 7, 4, 5, 3, 12, 9, 8, 2, 6, 11, 10}
    },
    { {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
      {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
      {0, 1, 10, 5, 12, 7, 6, 9, 8, 3, 4, 11, 2},
      {0, 1, 9, 10, 5, 2, 6, 12, 8, 4, 7, 11, 3},
      {0, 1, 12, 9, 10, 3, 6, 5, 8, 7, 2, 11, 4},
      {0, 1, 3, 4, 7, 10, 6, 2, 8, 12, 9, 11, 5},
      {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
      {0, 1, 5, 12, 9, 4, 6, 10, 8, 2, 3, 11, 7},
      {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
      {0, 1, 7, 2, 3, 12, 6, 4, 8, 10, 5, 11, 9},
      {0, 1, 4, 7, 2, 9, 6, 3, 8, 5, 12, 11, 10},
      {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
      {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
    }
  };

int words[][][] =
  { { {0},
      {11, 0},
      {16, 0},
      {24, 0},
      {31, 0},
      {1, 0},
      {28, 0},
      {27, 0},
      {15, 0},
      {25, 0},
      {13, 0},
      {0},
      {-22, 0}
    },
    { {0},
      {0},
      {-41, 0},
      {-29, 0},
      {-21, 0},
      {-44, -10, 0},
      {-17, 0},
      {-50, 0},
      {-18, 0},
      {-44, 0},
      {-43, 0},
      {0},
      {-12, 0}
    },
    { {0},
      {0},
      {20, 14, 0},
      {14, 20, 0},
      {20, 30, 0},
      {46, 0},
      {14, 0},
      {42, 0},
      {0},
      {-20, 0},
      {-49, -10, 0},
      {0},
      {-49, 0}
    },
    { {0},
      {0},
      {11, 23, 11, 0},
      {11, 36, 0},
      {11, 23, 26, 0},
      {23, 0},
      {0},
      {-36, -11, 0},
      {0},
      {-23, -10, 0},
      {-19, -11, 0},
      {0},
      {-19, -26, 0}
    },
    { {0},
      {0},
      {11, 18, -11, -15, 0},
      {11, 51, 7, 0},
      {11, 18, -26, -15, 0},
      {11, 15, 26, -18, 0},
      {0},
      {14, 32, -34, 0},
      {0},
      {11, 15, 11, -18, 0},
      {10, 0},
      {0},
      {0}
    }
  };

  // factorPerm() finds a word in the abstract generators which 
  //              represents perm.

  public VectorInt factorPerm(int perm[]) {

    // x = copy(perm); allocate buffer x1, x2
    int 
      x[]  = new int[nrPoints],
      x1[] = new int[nrPoints],
      x2[] = new int[nrPoints];
    for (int i = 0; i < nrPoints; ++i)
      x[i] = perm[i];

    // factor x, accumulating in w:
    //   x t[bp1^x]^-1 in Stab(bp1), etc.
    //   by induction
    //     x t1^-1 .. tN^-1 = id and
    //     w w1^-1 .. wN^-1 = id  ==>  w = wN .. w1.
    //
    VectorInt w = new VectorInt(); 
    for (int level = 0; level < nrBasepoints; ++level) {
    
      // fetch the basepoint image and transversal element
      int im   = x[ basepoints[level] ];  // basepoint image
      int t[]  = transversals[level][im]; // takes basepoint to im
      int wt[] = words[level][im];        // the word for t
      
      // check if im is in the orbit at all
      if (t[0] == -1) {

        // x is not in the group
        return new VectorInt();
      }
      
      // compute x := x * t^-1; w := wt * w;
      for (int i = 0; i < nrPoints; ++i)
        x1[i] = x[i];
      for (int i = 0; i < nrPoints; ++i)
        x2[t[i]] = i;
      for (int i = 0; i < nrPoints; ++i)
        x[i] = x2[ x1[i] ];
      w.prepend(wt);
    }
    
    // check x = 0
    for (int i = 0; i < nrPoints; ++i)
      if (x[i] != i)
        return new VectorInt();

    return w;
  }

  public int[] mapWord(VectorInt word) {

    // perm := id; allocate buffers perm1, perm2
    int 
      perm[]  = new int[nrPoints],
      perm1[] = new int[nrPoints],
      perm2[] = new int[nrPoints];
    for (int i = 0; i < nrPoints; ++i)
      perm[i] = i;

    // form the product of the generators
    for (int k = 0; k < word.length; ++k) {
      int g = word.elements[k];
      if (g > 0) {

        // perm := perm * generators[g-1]
        for (int i = 0; i < nrPoints; ++i)
          perm1[i] = perm[i];
        for (int i = 0; i < nrPoints; ++i)
          perm[i] = generators[g-1][ perm1[i] ];

      } else if (g < 0) {

        // perm := perm * generators[-g-1]^-1
        for (int i = 0; i < nrPoints; ++i)
          perm1[i] = perm[i];
        for (int i = 0; i < nrPoints; ++i)
          perm2[ generators[-g-1][i] ] = i;
        for (int i = 0; i < nrPoints; ++i)
          perm[i] = perm2[ perm1[i] ];

      }
    }
    return perm;
  }

// Solving M13
// ===========

/* int triangleMoves[][];
     specifies the moves to take in order to permute the 12 counters
     in the way the generators do. More precisely, move the counter
     at the position triangleMoves[g-1][i] for i in [0..2] to achieve
     the result of applying generators[g-1], that is generator g.
*/

int triangleMoves[][] =
  { { 1,  2, 0 }, { 1,  3, 0 }, {  1,  4, 0 }, {  1,  6, 0 }, { 1,  7, 0 }, 
    { 1,  8, 0 }, { 1,  9, 0 }, {  1, 10, 0 }, {  1, 12, 0 }, { 2,  4, 0 }, 
    { 2,  5, 0 }, { 2,  6, 0 }, {  2,  8, 0 }, {  2,  9, 0 }, { 2, 10, 0 }, 
    { 2, 11, 0 }, { 2, 12, 0 }, {  3,  4, 0 }, {  3,  5, 0 }, { 3,  6, 0 }, 
    { 3,  8, 0 }, { 3,  9, 0 }, {  3, 10, 0 }, {  3, 11, 0 }, { 3, 12, 0 }, 
    { 4,  5, 0 }, { 4,  6, 0 }, {  4,  7, 0 }, {  4,  8, 0 }, { 4,  9, 0 }, 
    { 4, 11, 0 }, { 5,  6, 0 }, {  5,  7, 0 }, {  5,  8, 0 }, { 5,  9, 0 }, 
    { 5, 10, 0 }, { 5, 12, 0 }, {  6,  7, 0 }, {  6, 10, 0 }, { 6, 11, 0 }, 
    { 6, 12, 0 }, { 7,  8, 0 }, {  7,  9, 0 }, {  7, 10, 0 }, { 7, 11, 0 }, 
    { 7, 12, 0 }, { 8, 10, 0 }, {  8, 11, 0 }, {  8, 12, 0 }, { 9, 10, 0 }, 
    { 9, 11, 0 }, { 9, 12, 0 }, { 10, 11, 0 }, { 11, 12, 0 } 
  };

  // move()  simulates the move c by modifying counterAt

  public void move(int counterAt[], int c) {

    // compute the positions k(c) and k(hole)    
    int kc = 0;
    while ((kc < 26) && (counterAt[kc] != c))
      kc += 2;

    int kHole = 0;
    while ((kHole < 26) && (counterAt[kHole] != 12))
      kHole += 2;

    // compute the position k(L) of the line L joining c and hole
    int kL = 1;
    while (
      (kL < 26) &&
      (!(
        ( ((kL +  1)%26 == kc) ||
          ((kL +  9)%26 == kc) ||
          ((kL + 21)%26 == kc) ||
          ((kL + 25)%26 == kc)
        ) &&
        ( ((kL +  1)%26 == kHole) ||
          ((kL +  9)%26 == kHole) ||
          ((kL + 21)%26 == kHole) ||
          ((kL + 25)%26 == kHole)
        )
      ))
    )
      kL += 2;

    // find the other two points of L, a and b
    int ka  = -1;
    int kb  = -1;
    int d[] = {1, 9, 21, 25};
    for (int i = 0; i < 4; ++i) {
      int k = (kL + d[i])%26;
      if ((k != kc) && (k != kHole)) {
        if (ka == -1)
          ka = k;
        else
          kb = k;
      }
    }

    // return the move counterAt-array
    int 
      a = counterAt[ka],
      b = counterAt[kb];
    counterAt[kHole] = c;
    counterAt[kc]    = 12;
    counterAt[ka]    = b;
    counterAt[kb]    = a;
  }

  // solve()          computes a short valid sequence of moves by
  //                  considering the vincinity of the current state
  //                  and calling solveDirectly() for all those points
  // solveDirectly()  solves the puzzle by factoring in M12

  public int[] solve(int counterAt[]) {
  
    // use solveDirectly()
    VectorInt wBest = solveInVincinity(counterAt, new VectorInt());

    // try a single move
    for (int c0 = 0; c0 < 12; ++c0) {
      VectorInt w = solveInVincinity(counterAt, new VectorInt(c0));
      if (w.length < wBest.length)
        wBest = w;
    }

    // try a two moves
    for (int c0 = 0; c0 < 12; ++c0) 
      for (int c1 = 0; c1 < 12; ++c1) {
        VectorInt w = solveInVincinity(counterAt, new VectorInt(c0, c1));
        if (w.length < wBest.length)
          wBest = w;
      }
    
    wBest.trim();
    return wBest.elements;
  }
  
  public VectorInt solveInVincinity(int counterAt[], VectorInt w) {
  
    // state := copy(counterAt)
    int state[] = new int[26];
    for (int i = 0; i < 26; ++i)
      state[i] = counterAt[i];
    
    // do the moves in w
    for (int i = 0; i < w.length; ++i)
      move(state, w.elements[i]);

    // append solution to w with cancelation
    int w1[] = solveDirectly(state);
    for (int i = 0; i < w1.length; ++i)
      if ((w.length > 0) && (w.elements[w.length-1] == w1[i]))
        --w.length;
      else
        w.append(w1[i]);
    
    return w;
  }

  public int[] solveDirectly(int counterAt[]) {

    // allocate the resulting list of moves
    VectorInt m = new VectorInt();

    // state = copy(counterAt)
    int state[] = new int[26];
    for (int i = 0; i < 26; ++i)
      state[i] = counterAt[i];

    // do a single move to bring the hole to tick 0
    int holeToTop = state[0];
    if (holeToTop != 12) {
      move(state, holeToTop);
      m.append(holeToTop);
    }
 
    // get the remaining permutation of the positions:
    //   Whatever is at tick 2*k should be brought to 2*perm[k].
    int perm[] = new int[13];
    for (int i = 0; i < 13; ++i)
      perm[i] = i;
    for (int c = 1; c < 13; ++c) 
      perm[c] = state[2*c] + 1;

    // factor the permutation into a word in the triangle moves
    VectorInt w = factorPerm(perm);

    // translate w into triangle moves:
    //   1. Since moves are specified by the counter which is to
    //      be moved and not by the tick position from which a
    //      counter is moved into the hole, we have to trace the
    //      positions of the counters to apply certain permutations.
    //   2. All generators are of order 2. In fact, they are 4-fold
    //      2-cycles. Hence, we need not distinguish g and g^-1.
    //   3. Moves of the form "x x" can be canceled out to id.
    //   4. Triangle moves are of the form "x y x", they have the
    //      same effect as "y x y", from the initial state. However,
    //      the saving in word length is only abount 1/6 * 1/3 = 6%.
    //   5. Note that the generators are counted from 1, 2, 3..
    //      and *not* as 0, 1, 2..
    
    for (int k = 0; k < w.length; ++k) {
      int g = w.elements[k];
      if (g > 0) {
        int t[] = triangleMoves[g - 1];
        for (int i = 0; i < t.length; ++i)
          addTriangleMove(state, m, t[i]);
      } else if (g < 0) {
        int t[] = triangleMoves[-g - 1];
        for (int i = 0; i < t.length; ++i)
          addTriangleMove(state, m, t[i]);
      }
    }

    m.trim();
    return m.elements;
  }
  
  void addTriangleMove(int state[], VectorInt m, int x) {  
    int c = state[ 2*x ];
    if (c != 12) {
      move(state, c);
      
      // cancel out "x x" if possible
      if ((m.length > 0) && (c == m.elements[m.length-1]))
        --m.length;
      else
        m.append(c);
    }
  }
}

/* VectorInt
     a class the objects of which represent lists of (int)s 
     of variable length.
*/

class VectorInt extends Object {
  int length     = 0;
  int elements[] = new int[10];

  public VectorInt() {
  }

  public VectorInt(int elt0) {
    length      = 1;
    elements[0] = elt0;
  }

  public VectorInt(int elt0, int elt1) {
    length      = 2;
    elements[0] = elt0;
    elements[1] = elt1;
  }

  public VectorInt(int elts[]) {
    length   = elts.length;
    elements = new int[elts.length];
    for (int i = 0; i < elts.length; ++i)
      elements[i] = elts[i];
  }

  // grow() increases this to provide at least minLength elements.
  
  void grow(int minLength) {
    if (minLength <= elements.length)
      return;
    
    // grow by at least 10%
    int newLength = elements.length + elements.length/10 + 1;        
    if (minLength > newLength)
      newLength = minLength;

    // reallocate 
    int elts[] = elements;
    elements   = new int[newLength];
    for (int i = 0; i < length; ++i)
      elements[i] = elts[i];      
  }

  // append() appends a single/array/VectorInt element(s)
  
  public void append(int elt) {
    grow(length + 1);
    elements[length++] = elt;
  }
  
  public void append(int elts[]) {
    grow(length + elts.length);
    for (int i = 0; i < elts.length; ++i)
      elements[length++] = elts[i];
  }
  
  public void append(VectorInt elts) {
    grow(length + elts.length);
    for (int i = 0; i < elts.length; ++i)
      elements[length++] = elts.elements[i];
  }
  
  // prepend() prepends int/array/VectorInt 
  
  public void prepend(int elt) {
    grow(length + 1);
    for (int i = length-1; i >= 0; --i)
      elements[i + 1] = elements[i];
    elements[0] = elt;
    length += 1;
  }
  
  public void prepend(int elts[]) {
    grow(length + elts.length);
    for (int i = length-1; i >= 0; --i)
      elements[i + elts.length] = elements[i];
    for (int i = 0; i < elts.length; ++i)
      elements[i] = elts[i];
    length += elts.length;
  }

  public void prepend(VectorInt elts) {
    grow(length + elts.length);
    for (int i = length-1; i >= 0; --i)
      elements[i + elts.length] = elements[i];
    for (int i = 0; i < elts.length; ++i)
      elements[i] = elts.elements[i];
    length += elts.length;
  }
  
  // trim()  shortens elements to length 
  
  public void trim() {
    if (elements.length == length)
      return;
      
    int elts[] = new int[length];
    for (int i = 0; i < length; ++i)
      elts[i] = elements[i];
    elements = elts;
  }
}